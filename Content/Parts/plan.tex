%!TEX root=../main.tex

\section*{Аннотация}

DSLab - программный фреймворк для имитационного моделирования и тестирования распределенных систем.

В проекте используется дискретно-событийный подход описания моделей и приложений, где события обрабатываются в пользовательских функциях (callback-ах). В рамках проекта добавлена возможность управлять событиями асинхронно.

\section*{Ключевые слова}

Распредленные системы, симуляция, асинхронность 


\newpage 

\section{Основные термины и определения}

\begin{enumerate}
    \item Распределенная система -- система, выполняющая определенную задачу по обработке данных и компьютерных вычислений и использующая для этого несколько независимых машин (узлов), каждый из которых обладает своими ресурсами, памятью и запущенными процессами.
    \item Симуляция -- это процесс создания модели реальной системы или процесса, которая может быть использована для изучения и предсказания поведения системы в различных условиях.
    \item DSLab -- программный фреймворк для имитационного моделирования и тестирования распределенных систем.
    \item Асинхронное программирование -- это парадигма программирования, основанная на неблокирующем ожидании, которое позволяет программам переключаться на выполнение других задач в ожидании длительных операций.
    \item Callback -- это функция или код, который передается в качестве аргумента другой функции или метода, для выполнения в более поздний момент в ответ на событие или операцию.
    \item Логирование -- хронологическая запись операций, выполненных в системе. Логирование позволяет сохранять информацию о состоянии системы, которую можно использовать для ее исследования и отладки.
\end{enumerate}

\newpage

\section{Введение}

\subsection{Описание проекта DSLab}

В силу широты охвата областей применения фреймворка он организован в виде набора слабо связанных программных модулей, использование которых будет осуществляться через их API. Это даст возможность пользователям фреймворка (исследователям, разработчикам, преподавателям) гибким образом собирать из модулей решения под свои цели, например симуляторы для конкретных типов систем или постановок задач.

Входящие в состав фреймворка модули можно условно разделить на три типа:
\begin{enumerate}
    \item 
    Базовые, функциональность которых используется остальными модулями (например, 
    
    реализация дискретно-событийного моделирования)
    \item
    Универсальные, функциональность которых может быть использована в различных предметных областях (например, модели сети);
    \item
    Специализированные, которые заточены под определенную предметную область (например, библиотеки для моделирования облачных инфраструктур, исследования алгоритмов планирования заданий на кластерах или тестирования решений учебных заданий).
\end{enumerate}

Архитектуру DSLab можно схематично представить в виде трех слоев (Рис. \ref{dslab_arc}), включающих модули соответствующего типа. На рисунке также указаны текущие модули и зависимости между ними. Зависимости от dslab-core (от него зависят все имеющиеся универсальные и специализированные модули) не указаны, чтобы не загромождать рисунок. Таким образом, модули могут зависеть от модулей с нижних слоев, но не наоборот.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{images/dslab_arc.png}
    \caption{Архитектура DSLab}
    \label{dslab_arc}
\end{figure}

Описание архитектуры основано на документации проекта \cite{dslab-architecture}. Более подробно про проект можно прочитать в его описании \cite{dslab-description}, его требования \cite{dslab-requirements} и сравнение с аналогами \cite{dslab-analog-cmp}. Реализации модулей представлены в репозитории \cite{dslab-repo}.

Таким образом пользователь при разработке собственной симуляции может либо использовать уже готовые разработанные компоненты, либо реализовывать свои и произвольно их связывать. 


Основным процессом в симуляции является создание событий и исполнения процессов реагирования на них.Разные компоненты генерируют события друг для друга и с помощью низкоуровневого модуля dslab-core обмениваются ими. Чтобы как-то реагировать на событие, каждый компонент реализует единственный обобщенный метод в который dslab-core передает нужное событие. При обработке события компоненты генерируют новые и таким образом цикл симуляции замыкается. 

Получается, что сейчас реагировать на пришедшие события можно только в одном месте -- в той самой функции-callback которую позовет dslab-core. В случае, когда событий немного -- это лаконично выглядит и этим удобно пользоваться. Но в более сложных алгоритмах с большим количеством различных событий, и, что важнее, цепочками событий, на которые нужно последовательно реагировать, подобная модель становится не самой удобной. С такой единой точной входа многие последовательные логичные действия оказываются фрагментированы (разбросаны по разным участкам кода). 

Хотелось бы иметь альтернативную возможность писать на языке программирования более понятный с первого взгляда алгоритм.

Как раз такой возможностью является написание асинхронного кода. Тогда различные сложные куски логики можно было бы выносить в отдельные функции, держать их вместе, просто исполнение бы прерывалось в ожидании какого-то события, чтобы продолжить.

\subsection{Цель и основные требования}
\begin{itemize}
    \item Реализовать асинхронное расширение для существующего ядра dslab-core или реализовать альтернативное асинхронное ядро 
    \item Добавить примеры использования нового функционала высокоуровневыми компонентами
    \item Написать подробную документацию нового API и покрыть реализацию тестами.
    \item Новое ядро должно быть реализовано эффективно: не должны возникать дополнительные (асимптотически) накладные расходы по сравнению со стандартным ядром.
\end{itemize}

\section{Актуальность и значимость}

\subsection{Значимость проекта DSLab}

Практически все современные информационные и вычислительные системы являются распределенными. Связано это с растущими объемами вычислений и обрабатываемых данных, требованиями к производительности, надежности и масштабируемости. Алгоритмическое обеспечение распределенных систем (например, алгоритмы управления ресурсами, планирования задач, балансировки нагрузки, членства в группе, консенсуса) является предметом активных исследований. В силу масштабов современных систем, сложности их реализации и недетерминированного характера, исследование алгоритмов и тестирование их реализаций в реальных системах существенно затруднено. Поэтому часто подобные исследования проводятся на аналитических и имитационных моделях, описывающих существенные для решаемой задачи аспекты поведения системы и проводимых вычислений. Использование моделей позволяет значительно удешевить эксперименты, сократить время их проведения и обеспечить воспроизводимость их результатов \cite{dslab-description}. 

\subsection{Преимущества асинхронного подхода}

Как уже было описано в мотивации постановки цели этой работы, главное преимущество асинхронной модели~--~удобство при написании сложных многоступенчатых алгоритмов.

Это повысит читаемость кода. Процесс принятия решения о сохранении файла в распределенном хранилище в такой парадигме мог бы выглядеть таким образом (псевдокод):

\begin{figure}[H]
\begin{lstlisting}[language=Python]
    async fn add_file_to_storage(some_file) {
        send_file_to_all_replicas(some_file);
        result = wait_for_confirmation_from_all().await;
        if result.has_quorum {
            send_commit_to_all_replicas();
            wait_for_commit_confirmation_from_quorum(result.nodes).await;
            send_ok_message_to_user();
        } else {
            send_reject_message_to_user();
        }
    }
\end{lstlisting}
\caption{Псевдокод асинхронного взаимодействия нод в симуляции}
\label{pseudocode}
\end{figure}

Посмотрев на функцию можно понять, что она делает, потому что логика последовательна и удобно разбита на подфункции. У нас есть возможность написать такой алгоритм на верхнем уровне, а не обрабатывать сообщения всех типов от всех реплик в единой точке входа.

\subsection{Возможные недостатки асинхронного подхода}

Программировать в парадигме асинхронного взаимодействия требует соответствующей подготовки пользователя. Не смотря на то, что в любой момент времени исполняется только одна функция, и проблем многопоточного программирования вида \texttt{data-race} не возникает, нужно постоянно держать в голове, что <<параллельно>> могут быть запущены другие процессы, которые могли поменять общую память в то время, когда функция была неактивна. 

\section{Существующие работы и решения}

Подобный подход уже был реализован в других симуляторах, например в SimGrid \cite{simgrid-example}. Главное отличие подхода DSLab от SimGrid -- наличие дискретно-событийного моделирования. В SimGrid компоненты общаются между собой асинхронно через MailBox-ы (аналог канала из языка Go). Также код из примера сложно назвать легко читаемым, потому что SimGrid -- низкоуровневый фреймворк.

Более близким к желаемой реализации является использование корутин языка Kotlin в проекте OpenDC~\cite{opendc-repo}. К сожалению, проект не содержит достаточно разнообразных примеров использования симуляции в асинхронном контексте, но простой пример запуска симуляции в асинхронном контексте~\cite{opendc-example} очень похож на ожидаемый опыт использования асинхронности в DSLab.


Опыт других проектов не очень хорошо подходит как опора для разработки нового решения из-за специфики языка Rust и внутренней архитектуры симулятора.


\section{Управление исполнением}

Чтобы дать возможность пользователю писать асинхронный код, нужно создать саму возможность обрабатывать события асинхронно. Для этого нужно написать свой executor задач в DSLab, который будет исходя из внутренней логики (наступление времени, когда событие нужно доставить получателю) понимать, когда и какую асинхронную задачу нужно разбудить, и дать ей продолжить исполнение. 

К счастью, язык Rust дает возможность пользователям самим управлять процессом рантайма: с помощью библиотеки futures \cite{rust-futures} такое поведение может быть реализовано (что на простом примере и описано в официальной документации \cite{async-book}).

В основе подхода асинхронного исполнения в языке Rust лежат stackless-корутины. Каждая асинхронная функция превращается в state-machine. На высоком уровне это объект с фукнциями-callback-ами, внутри которых нет асинхронного ожидания. Т.е. компилятор <<разрезает>> за нас эту функцию на части, которые нам нужно будет исполнить. Это ровно то, что сейчас разработчик, использующий DSLab делает самостоятельно. В существующей модели исполнения каждый компонент предоставляет ядру набор callback-ов на каждое событие, которые должен написать пользователь. Из-за этого код получается искусственно <<разрезан>> на части в местах ожидания событий. В асинхронном подходе мы пишем стандартную фукнцию, используя \texttt{.await} для ожидания, и компилятор разрезает эту функцию за нас. Наглядно можно продемонстрировать разницу на вот таком участке эквивалентного псевдокода: 

\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.45\linewidth}
        \centering
        \begin{lstlisting}[language=Python]
fn on_start_action(&self) {
    // do 1
}
fn on_first_event(&self) {
    // do 2
}
fn on_second_event(&self) {
    // do 3
}
    \end{lstlisting}
        \caption{Синхронный код (разрезан на части разработчиком)}
        \label{sync-async-example:sync}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.45\linewidth}
        \centering
        \begin{lstlisting}[language=Python]
async fn action(&self) {
    // do 1
    wait_for_first_event().await;
    // do 2 
    wait_for_second_event().await;
    // do 3
}
    \end{lstlisting}
        \caption{Асинхронный код (разрезан на части компилятором)}
        \label{sync-async-example:async}
    \end{subfigure}
\caption{Сравнение синхронного и асинхронного кода на языке Rust}
\label{sync-async-example}
\end{figure}

Как можно ожидать, ни один из этих примеров не исполняется сам. В случае синхронного примера (\ref{sync-async-example:sync}) очевидно, что у него нет <<единой точки запуска>>, т.е. каждую из трех функций-callback-ов должно позвать ядро исполнения симуляции (dslab-core). 

Для асинхронного примера (\ref{sync-async-example:async}) действует то же самое правило: на при наступлении соответствующего события нужно <<разбудить>> эту функцию и дойти до следующего места ожидания. Именно такую возможность и нужно поддержать в dslab-core. 

Главный компонент исполнителя задач -- логика, по которой нужно ставить на исполнение ту или иную задачу в dslab-core уже реализована. Это и есть основа всей дискретно-событийной симуляции. Остается только добавить возможность <<возобновлять>> исполнение асинхронной функции как раз в том месте, где сейчас вызывается заранее зарегистрированный пользовательский callback.


\section{Дизайн и структура ядра DSLab (dslab-core)}

\subsection{Событие} \label{Event}
Основа дискретно-событийного моделирования -- события. В фреймворке DSLab они представленны структурой \underline{\texttt{Event}} со следующими полями: 
\begin{itemize}
    \item \texttt{id: EventId} -- уникальный идентификатор события во всей симуляции
    \item \texttt{time: f64} -- время наступления события 
    \item \texttt{src: Id} -- идентификатор компонента симуляции, создавший это событие 
    \item \texttt{dest: Id} -- идентификатор компонента симуляции, которому это событие предназначается
    \item \label{Event:payload} \texttt{data: Box<dyn EventData>} -- произвольная <<полезная нагрузка>> события, которая может иметь любой тип и определяется пользователем. 
\end{itemize}

\subsection{Обработчик событий} \label{EventHandler}

Обрабатывать события симуляции в DSLab может любой класс, реализующий интерфейс \underline{\texttt{EventHandler}}. Этот интерфейс содержит единственную функцию: 
\begin{center}
\texttt{fn on(\&mut self, event: Event)}
\label{fnon}
\end{center}

Именно эта функция вызывается как callback для обработки полученного события.

\subsection{Основные классы симуляции}
Модуль dslab-core состоит из нескольких основных классов, логически разделенных друг от друга:
\begin{itemize}
    \item \texttt{Simulation} \label{Simulation} -- основной класс, отвечающий за симуляцию. С него начинается создание любой симуляции. Он же предоставляет API для контроля за событиями. Основные методы:
    \begin{itemize}
        \item \label{Simulation::step} \texttt{Simulation::step() -> bool} -- сделать один <<шаг>> симуляции. Это значит взять из очереди событие с наименьшим временем наступления и вызвать обработчик у компонента, которому это событие предназначается. Возвращает \texttt{true} если все перечисленные действия успешно завершились. 
        \item \texttt{Simulation::time() -> f64} -- вернуть текущее время симуляции (вещественное число). Оно совпадает с временем последнего обработанного события. 
        \item \label{Simulation::createcontext} \texttt{Simulation::create\_context(name: \&str) -> SimulationContext} -- Создать контекст для компонента с именем \texttt{name} симуляции, с помощью которого тот будет отправлять события.
    
        \item \texttt{Simulation::add\_handler(name: \&str, handler: dyn EventHandler)} -- Добавить обработчик событий для компонента с именем \texttt{name}.
        Этот метод принимает любой класс, реализующий публичный интерфейс \hyperref[EventHandler]{EventHandler}. Когда компоненту \texttt{name} нужно будет доставить какое-либо событие (в рамках исполнения метода \hyperref[Simulation::step]{Simulation::step()}), именно эта функция будет вызвана для обработки события.
        \item Набор методов для генерации псевдослучайных последовательностей. Опустим эти детали, поскольку эта часть не очень важна в данной работе.
    \end{itemize}
    \item \texttt{SimulationState} -- класс состояния симуляции. Является полем класса \texttt{Simulation} и хранит в себе всю информацию о симуляции: очереди событий и отмененные события.
    \item \texttt{SimulationContext} -- контекст одного компонента симуляции. Является продуктом вызова функции \hyperref[Simulation::createcontext]{Simulation::create\_context}. В предполагаемом дизайне системы является полем класса, отвечающем за функционал отдельного компонента симуляции. Основные методы API для взаимодействия с симуляцией:
    \begin{itemize}
        \item \texttt{SimulationContext::emit<T>(data: T, dest: Id, delay: f64) -> EventId} -- добавить в симуляцию событие. Принимает данные произвольного типа T и создает \hyperref[Event]{событие} с этими данными, которое должно быть доставленно компоненту симуляции с идентификатором \texttt{dest} через время \texttt{delay} (разумеется, речь идет о внутреннем времени симуляции). В момент, когда событие будет доставлено, у соответствующего класса будет вызывана \hyperref[fnon]{функция-callback}. Тот класс в свою очередь (уже с помощью своего SimulationContext::emit) сможет добавлять новые события в симуляцию, и таким образом цикл замыкается, симуляция продолжается.
        \item \texttt{SimulationContext::cancel\_event(id: EventId)} -- отменить наступление события с заданным идентификатором. \label{SimulationContext} 
    \end{itemize}
\end{itemize}

\section{Добавление асинхронности}

Поскольку существующий \texttt{dslab-core} -- уже готовый планировщик задач, то было решено расширить его функционал для работы с асинхронными функциями. При таком подходе сохраняется обратная совместимость со всеми уже написанными компонентами: можно использовать модель callback-ов для других компонент и даже совмещать две парадигмы внутри одного компонента. 

\subsection{Ожидающие компоненты}

Ключевой вопрос, который предстояло решить: <<Каким образом будет организовано асинхронное ожидание внутри симуляции?>> Для этого нужно обратиться к смыслу дискретно-событийного моделирования: компоненты обмениваются между собой событиями. Соответственно, разрыв в процессе работы какого-то компонента может произойти по двум причинам:
\begin{enumerate}
    \item Необходимо дождаться какого-то события от другого компонента 
    \item Необходимо подождать какое-то количество времени (внутри симуляции) и возобновить исполнение (иными словами <<завести таймер в симуляции>>). Поддержать такое становится возможно с помощью предыдущего пункта и отправки событий самому себе. 
\end{enumerate}

Из этих двух потребностей и вытекает пользовательский интерфейс -- нужно уметь блокироваться, ожидая событие от другого компонента. Для этого в \texttt{dslab-core} был добавлен \texttt{Future} для события. Таким образом каждый, кто хочет дождаться какого-то события асинхронно, отправляет соответствующий запрос к симуляции (или через SimulationContext) и получает на выход \texttt{Future} на это событие. 

\subsection{Ключи ожидания} \label{awaitkey}

Для того, чтобы сохранить константную асимптотику обработки события внутри ядра, необходимо для каждого события понимать, куда его нужно доставить за константное время. Было решено каждому событию сопоставить некоторый <<ключ>>. В реализации \texttt{dslab-core}~\cite{async-dslab-core} эта структура называется \texttt{AwaitKey} и содержит следующие поля: 
\begin{itemize}
    \item \texttt{src: Id} -- идентификатор компонента, отправляющий событие
    \item \texttt{dst: Id} -- идентификатор компонента, получающий событие
    \item \texttt{msg\_type: TypeId} -- идентификатор типа \hyperref[Event:payload]{<<полезной нагрузки>>}, которую несет в себе событие -- уникальный для каждого типа в рамках программы 
    \item \texttt{details: u64} -- внутренние детали <<полезной нагрузки>> для более точной настойки ожидания, получаемые за константное время (заполняются нулем, если таковые отсутствуют).
\end{itemize}  

Как можно заметить, при наличии события, такой вот \texttt{AwaitKey} можно посчитать за константное время, таким образом каждый ожидающий компонент обращается к симуляции с подобным ключом, <<регистрируясь>> на ожидание события конкретного типа от конкретного другого компонента.

При наступлении следующего события в методе \hyperref[Simulation::step]{Simulation::step()} можно за константное время посчитать его \texttt{AwaitKey} и проверить, подписывался ли кто-то на получение конкретно этого события или нет. 

В случае, если такой ожидающий компонент находится, событие доставляется уникально в это место ожидания. После этого возобновляется работа прерванной на ожидание задачи до следующего ожидания (см пример \ref{sync-async-example:async}).

В случае, если конкретно на полученном \texttt{AwaitKey} никто не ждет, задействуется стандартная процедура вызова \hyperref[fnon]{функции-callback-a}.

\subsection{Детализированное ожидание} \label{detailed-await}

В рамках асинхронного ожидания мы можем ждать сообщение какого-то конкретного типа от какого-то конкретного компонента. Оказывается, этого не всегда достаточно. 

Рассмотрим простейший пример: есть несколько нод и они общаются друг с другом через компонент сети. Тогда сигналом о завершении передачи данных будет соответствующее событие (например \texttt{DataTransferCompleted}), полученное от компонента-сети. Проблема в том, что таким образом будет заканчиваться любая передача данных в такой симуляции. Такая модель ограничивает нас в каждый момент времени держать ровно одну активную передачу данных, иначе невозможно будет однозначно определить по паре \texttt{\{id сети, тип события\}} какая именно из передач завершилась, и какую именно активность стоит продолжить в рамках симуляции. 

С такими жесткими ограничениями использование такой модели не представляет никакого интереса, поэтому нужно еще сильнее сузить и конкретизировать запрос на ожидание события. Ровно для этого в \hyperref[awaitkey]{ключе ожидания} есть дополнительное поле \texttt{details}. Обычно подобные взаимодействия сопровождаются неким \texttt{request\_id} или подобным полем, однозначно идентифицирующим конкретный запрос или процесс. 

Возвращаясь к примеру: при отправке запроса на передачу данных мы можем возвращать пользователю идентификатор этой передачи (за которым следит компонент сети), и поскольку в сообщении \texttt{DataTransferCompleted} тоже будет присутствовать этот идентификатор, мы можем добавить его как подробности для ожидания. Получится примерно такое использование: 
\begin{figure}[H]
\begin{lstlisting}[language=Python]
    async fn process_data_transfer_request(&self, request: Request) {
        let request_id = self.network.send(request);
        async_detailed_handle_event::<DataTransferCompleted>(
            self.network.id, 
            request_id,
        ).await;
    }
\end{lstlisting}
\caption{Псевдокод асинхронного ожидания детализированного события}
\label{async-detailed-pseudocode}
\end{figure}

\section{Асинхронный интерфейс для пользователя} \label{interface}

\subsection{Описание API}

Поскольку компоненты взаимодействуют с симуляцией через \hyperref[SimulationContext]{SimulationContext}, то именно это API было расширено. Новый функционал \texttt{SimulationContext} можно разделить на 4 категории: 
\begin{enumerate}
    \item Старт асинхронных активностей. Чтобы пользоваться асинхронным ожиданием, нужно создать корневую асинхронную активность, из которой уже будут вызываться асинхронные функции контекста. Для этого предоставляется единственная функция: 
    \begin{itemize}
        \item \texttt{fn spawn(\&self, future: impl Future<Output = ()>)} -- запуск асинхронной активности без возможности как-либо на нее повлиять. Стандартный паттерн для асинхронного рантайма. Такой активностью может быть любая асинхронная функия или метод класса с пустым возвращаемым значением. \label{spawn}
    \end{itemize}
    \item Завести таймер и подождать произвольное время внутри симуляции: 
    \begin{itemize}
        \item \texttt{async fn async\_wait\_for(\&self, timeout: f64)} -- возвращает объект Future, у которого будет пустой результат через \texttt{timeout} внутреннего времени симуляции. Чтобы получить результат, нужно позвать встроенный \texttt{.await}.
    \end{itemize}
    \item Асинхронное ожидание событий без таймаута. 
    \begin{itemize}
        \item \texttt{async fn async\_handle\_event<T>(\&self, src: Id) -> (Event, T)} -- асинхронно дождаться события с \hyperref[Event:payload]{<<полезной нагрузкой>>} типа T от компонента с идентификатором \texttt{src}. Возвращает объект типа Future, на который нужно сделать \texttt{.await}.
        \item \texttt{async fn async\_detailed\_handle\_event<T>(\&self, src: Id, details: u64) -> (Event, T)} -- асинхронно дождаться события с \hyperref[Event:payload]{<<полезной нагрузкой>>} типа T и внутренней информацией details (см псевдокод в примере \ref{async-detailed-pseudocode}) от компонента с идентификатором \texttt{src}. Возвращает объект типа Future, на который нужно сделать \texttt{.await}.
    \end{itemize}
    \item Асинхронное ожидание с таймаутом. Тут можно справедливо заметить, что стандартные функции работы с типом \texttt{Futures} в \texttt{Rust} позволяют вывести этот пункт из предыдущих двух и макроса \texttt{fututes::select!} из библиотки \texttt{futures} \cite{rust-futures}. Но т.к. это довольно востребованный сценарий альтернативного ожидания было принято решение поддержать его отдельно. Это сокращает накладные расходы внутри dslab-core по причинам внутренней реализации.Результатом такого ожидания будет либо событие, либо сообщение об истекшем таймере. Реализовано это с помощью \texttt{enum AwaitResult}, который либо содержит событие либо сообщение об истекшем таймере. Методы (все возвращают объект типа \texttt{Future}, на которые нужно сделать \texttt{.await}):
    \begin{itemize}
        \item \texttt{async fn async\_wait\_for\_event<T>(\\\&self, src: Id, timeout: f64,\\) -> AwaitResult<T>} -- для обычного ожидания
        \item \texttt{async fn async\_detailed\_wait\_for\_event<T>(\\\&self, src: Id, details: u64, timeout: f64,\\) -> AwaitResult<T>} -- для детализированного ожидания. 
    \end{itemize}
\end{enumerate}

\subsubsection{Добавление деталей к событиям}

Поскольку события все находятся в общей очереди, то получать детали внутренней <<полезной нагрузке>> необходимо будет самому компоненту \texttt{dslab-core}, во время обработки событий. Для этого предоставлен следующий интерфейс:
\begin{flushleft}
     \texttt{fn register\_details\_getter\_for<T: EventData>(}
\end{flushleft}
\vspace{-1.2cm}
\begin{flushright}
      \texttt{\&self, getter: fn(\&dyn EventData) -> u64)}
\end{flushright}

Такой метод есть у \hyperref[Simulation]{Simulation} и у \hyperref[SimulationContext]{SimulationContext}. Для каждого типа событий, на которых планируется выполнять детализированное ожидание (за все время симуляции), необходимо через один из этих методов зарегистрировать функцию, которая будет определять детали. Подробнее можно посмотреть в примере \texttt{async-event-details} в DSLab \cite{async-event-details-example}

\subsection{Примитивы синхронизации}

Был реализован простейший примитив синхронизации -- канал передачи данных. Семантика очень похожа на канал из языка \texttt{Go}, только канал бесконечного размера, и блокирующими являются только операции получения данных из канала. Эталонный пример его использования можно посмотреть в \texttt{async-event-details} \cite{async-event-details-example}. 

Стоит отметить, что на похожих каналах основано все взаимодействие в фреймворке \texttt{SimGrid}~\cite{simgrid-example}. Там акторы общаются между собой через похожие \texttt{MailBox-ы}.


\subsection{Ограничения при использовании}
Для удобства использования асинхронного фреймворка и быстроты его работы необходимо было пойти на некоторые компромиссы: 
\begin{itemize}
    \item 
    \underline{Одновременно обычное и детализированное ожидание событий невозможно}, потому что отсутствие детализированного ожидание приравнивается к ожиданию на <<нулевых>> деталях, а значит события с ненулевыми деталями получены за константное время быть не могут. 
     
    \item 
    \underline{При асинхронном взаимодействии можно использовать только \texttt{immutable} ссылки}. Это связано с ограничениями языка \texttt{Rust}: на один объект может быть не более одной \texttt{mutable}-ссылки, одновременно \texttt{mutable} и \texttt{immutable} ссылки существовать не могут. Из-за этого приходится пользоваться проверкой этих правил в runtime с помощью класса \texttt{RefCell}. Заметим, что на объект создается новая ссылка каждый раз при вызове метода \hyperref[spawn]{spawn} (ссылка на \texttt{self}), поэтому все методы контекста требуют \texttt{immutable} ссылка на \texttt{self}
    
    \item 
    Объекты, отвечающие за симуляцию компонентов стоит разрушать только методами, предоставленными в симуляции. Нужно, чтобы избежать неопределенного поведения программы. При задуманном дизайне разработки компоненты вообще не придется разрушать и перемещать до окончания работы программы (симуляции).
    
\end{itemize}

\section{Внутреннее устройство и реализация}

Полная реализация приведена в моем форке репозитория \texttt{DSLab} \cite{async-dslab-core}. Этот раздел будет дополнен деталями.

\subsection{Задача}

Любая асинхронная активность начианется с метода \hyperref[spawn]{spawn}. Таким образом корневая асинхронная функция становится задачей, с которой мы возобновляем исполнение. Задача обладает способностью разбудить себя (хранит в себе ссылку на очередь задач и при вызове соответствующего метода добавляет себя в эту очередь, чтобы потом исполнитель задач ее исполнил).

\subsection{Исполнитель задач}

К полям Simulation добавляется еще поле типа \texttt{Executor} -- исполнитель задач. Он предоставляет единственный метод: \texttt{fn process\_task()} -- выполнить первую в очереди задачу. В случае, если асинхронная активность завершилась, ее объект нужно разрушить, чтобы не было утечек памяти.

\subsection{Разделяемое состояние}

Чтобы передавать данные между \texttt{dslab-core} и пользовательским кодом асинхронно, у каждого \texttt{Future} есть разделяемое состояние -- ссылка на разделяемую структуру в динамической памяти. Эта ссылка передается в \texttt{dslab-core}, чтобы в эту <<корзинку>> можно было <<положить>> пришедшее событие для конкретного \hyperref[awaitkey]{AwaitKey}. Эта же ссылка передается в реализованные \texttt{Future}, из которой они <<достают>> результат и возвращают его пользователю. 

\section{Эксперименты и замеры производительности}

\subsection{Раздельная сборка}

Поскольку необходимость поддерживать асинхронную функциональность замедляет ядро, было принято решение включать ее по опции (в языке Rust к пакетам можно добавлять разные \texttt{features}, которые влияют на сборку). Таким образом, если асинхронность не используется в каком-то проекте, ее можно не подключать и не получить никакой просадки производительности. 

Аналогичная логика работает с детализированным ожиданием -- оно также создает дополнительную нагрузку на ядро на обработку каждого события, поэтому этот функционал тоже включается по опции. Все возможные опции подключения пакета из примеров перечислены ниже (относительный путь до пакета \texttt{dslab-core} может быть другим): 
\begin{itemize}
    \item \small \texttt{dslab-core = \{ path = "../../crates/dslab-core" \}} -- асинхронность не поддерживается. 
    
    Максимальная производительность. 
    \item \small \texttt{dslab-core = \{ path = "../../crates/dslab-core", features = ["async\_core"] \} } -- поддерживается весь \hyperref[interface]{интерфейс}, кроме функций детализированного ожидания. 
    \item \small \texttt{dslab-core = \{ path = "../../crates/dslab-core", features = ["async\_details\_core"] \}} -- поддерживается весь функционал API. Производительность снижена относительно стандартного \texttt{dslab-core}.
\end{itemize}

\subsection{Замеры на схожих примерах}

\subsubsection{Ping-pong}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|c|c|}
        \hline
        Example & Hosts & Peers per host & Iterations & Elapsed time & Events/s & Iterations/s \\
        \hline
        async-ping-pong & 100000 & 100 & 100 & 16.45s & 1234103 & 6.08\\
        \hline
        ping-pong & 100000 & 100 & 100 & 8.20s & 2452670 & 12.20\\
        \hline
    \end{tabular}
    \caption{Сравнение производительности async-ping-pong и ping-pong.}
    \label{cmp:ping-pong}
\end{table}

Видим двукратную деградацию в производительности. Естественно это связано с дополнительными расходами на асинхронность. Для каждого события необходимо посчитать его \hyperref[awaitkey]{AwaitKey}, достаить его в соответствующий \texttt{SharedState}, поставить задачу на исполнение в \texttt{Executor} и выполнить задачу.

Однако, \texttt{ping-pong} -- это довольно вырожденный пример. Обычно значительное время работы симуляции занимает как раз работа пользовательского кода (в этом примере она полностью отсутствует). С точки зрения приближенности к реальным условиям показательнее будет следующий пример. 

\subsubsection{Master-workers}

Сравнивался существующий синхронный пример \texttt{master-workers} \cite{master-workers-example} с асинхронным аналогом \texttt{async-master-workers} \cite{async-master-workers-example}. Примеры различаются лишь подходом к обработке событий, логика и симуляция в примерах полностью совпадают. Оба примера были запущены с параметрами 100 хостов и 100000 задач. Получились такие результаты:

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        Example & Tasks & Hosts & Elapsed time & Scheduling time & Events per second \\
        \hline
        async-master-workers & 100000 & 100 & 5.97s & 4.31s & 285059 \\
        \hline
        master-workers & 100000 & 100 & 5.19s & 4.31s & 328392 \\
        \hline
    \end{tabular}
    \caption{Сравнение производительности async-master-workers и master-workers.}
    \label{cmp:master-workers}
\end{table}

Тут как можно заметить результаты не такие разные, т.к. основное время тратится в пользовательской симуляции (на Scheduling time), а не на обмен событиями. Использование асинхронности никак не замедляет и не ускоряет пользовательский код не связанный с обменом событий. 

\section{Производительность при увеличении симуляции}

Тут будут построены еще графики, показывающие производительность на тех двух примерах с разными входными данными чтобы показать $O(NlogN)$ зависимость от числа компонент и линейную зависимость от числа событий в симуляции.

\section{Логгирование событий}

Поскольку асинхронное управление событиями было добавленно как расширение к уже существующему ядру, дополнительное логгирование событий не понадобилось, т.к. оно уже присутствовало в \texttt{dslab-core}.

\section{Результаты и планы на будущее}

Главным результатом работы стало работающее расширение модуля \texttt{dslab-core} \cite{async-dslab-core} и написанные к нему примеры \cite{async-ping-pong-example}\cite{async-event-details-example}\cite{async-master-workers-example}. 

В качестве дальнейшей работы можно улучшить документацию, которая является несовершенной. 


